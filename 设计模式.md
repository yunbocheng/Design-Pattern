# 23种设计模式

## 1.设计模式概念

### 1.1 什么地方可以用到设计模式

```markdown
面向对象(OO)=>功能模块[设计模式+算法(数据结构)]=>框架[使用多种设计模式]=>架构[服务器集群]
```

### 1.2 使用设计模式的好处

- 使用设计模式，软件具有很好的可扩展性(可以增加新的功能)
- 使用开发模式，具有很好的维护性(可读性、规范性)

### 1.3 设计模式的目的

- 设计模式是为了让程序，具有更好的代码重复性、可读性(编程规范性)、可扩展性(可维护性)、可靠性、是程序呈现**高内聚，低耦合**的特征。(模块内部逻辑关系非常紧密，模块与模块之间的关系非常的松散)
- 分享金句："懂了设计模式，你就懂了面向对象分析和面向对象设计(OOA/OOD)的精要"。

- C++老手与C++新手的区别就是，前者手背上有很多的伤疤。

## 2.设计模式的七大原则

- 设计模式原则，其实就是程序员在编译时，应当遵守的原则，也就是各种设计模式的基础(即：设计模式为什么这样设计的依据)

**设计模式常用的七大原则：**

- 单一职责原则

- 接口隔离原则
- 依赖倒转(倒置)原则
- 里氏替换原则
- 开闭原则
- 迪米特原则
- 合成复用原则(在一些地方不写这个原则)

### 2.1 单一职责原则

- 对于类来说，即一个类应该只负责一项职责。如果A类负责两个不同的职责：职责1、职责2。当职责1发生变化而改变A时，可能会对职责2造成影响使职责2运行错误，所以需要将类A的粒度分解为A1、A2。
- 如果再类中没有满足单一职责原则，在一个类的方法中遵守单一职责原则也是可以的(交通工具)

- 标准的单一职责原则，是在类的级别上进行拆分，而不是方法级别。

- 通常情况下，我们要遵守单一职责原则，只有当逻辑足够简单，才可以在代码级别违反单一职责原则；只有类中的方法数量足够少，可以在方法级别保持单一职责原则。

- 优秀的代码中使用类来区分多个分支，而不使用 if...else if()....else(耦合度高)

### 2.2 接口隔离原则

- 客户端不应该依赖它不需要接口，即一个类对另一个类的依赖应该建立在最小的接口上。
- 处理方式：将接口Interface拆分为独立的几个接口，类A与类C分别于他们需要的接口建立依赖关系。这就是使用的接口隔离原则。

没有使用接口隔离原则时的实现类图：(此时A、C要实现接口里的所有方法)

<img src="https://gitee.com/YunboCheng/imageBad/raw/master/image/20210911144651.png" style="zoom:80%;" />

使用接口隔离原则时的实现类图：(此时将接口进行了拆分，A此时只需要实现它要使用的方法对应的接口即可，而不用将接口中的方法全部实现)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210911144847.png)

### 2.3 依赖倒转(倒置)原则

- 在Java中，抽象是指接口或者抽象类，细节是指具体的实现类。

- 高层模块不应该依赖低层模块，二者都应该依赖其抽象(接口、抽象类)。
- 抽象类不应该依赖细节，细节应该依赖抽象类。

- 依赖倒倒转(倒置)的中心思想是面向接口编程。

**依赖倒转原则是基于这样的设计理念：**

- 相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比细节为基础的架构要稳定的多。
- 使用接口或者抽象类的目的是制定好规范，而不涉及任何具体的操作，把展示细节的任务交给他们的实现类去完成。

注意：在一个类文件中可以声明其他类、接口，只是这些都不能使用public修饰。但是声明的这些类和方法还是可以被其他的类继承或者实现的。

**依赖关系传递的三种方式**

- 接口传递
- 构造方法传递
- setter方式传递

**依赖原则要注意的地方**

- 底层模块尽量都要有抽象类和接口，或者两者都有，程序稳定性更好。
- 变量的声明类型尽量是抽象类和接口，这样我们的变量引用个实际对象间，就曾在一个缓冲层，利于程序的扩展和优化。(就比如你和对象吵架，你先找丈母娘来劝说对象，而不是与对象直接沟通)
- 继承时遵循里氏替换原则。

### 2.3  里氏替换原则

- 使用继承的时候，父类会对子类进行约束。并且如果父类中的方法发生改变的时候，可能会对所有的子类造成影响。

**里氏替换原则**

- 里氏替换原则是在1988年麻省理工学院的一个姓李的女士提出的。
- 所有引用基类的地方必须先是透明的使用其子类的对象。
- 在继承中，遵循里氏替换原则，在子类中尽量不在重写父类的方法。
- 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合、组合、依赖来解决问题。

**解决问题的办法**

- 原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等关系替代。

### 2.5 开闭原则(ocp原则)

- 开闭原则是编程中**最基础、最重要**的设计原则。
- 一个软件的实体如类、模块和函数应该对扩展开放(针对提供方)，对修改关闭(对使用者)。
- 用抽象构建架构，用实现扩展细节。
- 当软件需要变化时，尽量通**过扩展软件**实体的行为来实现变化，而**不是通过修改**已有的代码来实现。

- 编程中遵循其他原则，以及使用设计模式的的目的就是遵循开闭原则。

### 2.6 迪米特法则

- 一个对象应该对其他对象保持最少的了解。
- 类与类关系越密切，耦合度越大。
- **迪米特法则又叫最少知道原则**，即一个类对自己依赖的类知道的越少越好。也就是说，对于依赖的类不管多么的复杂，都尽量将逻辑封装在类的内部。对外除了了提供public 方法，不对外泄露任何信息。
- 迪米特法则还有个人更简单的定义：只与直接的朋友通信。
- **直接的朋友: **每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式有很多，依赖、关联、组合、聚合等。其中**，我们称出现在成员变量、方法参数、方法的返回值中的类为直接的朋友**，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类不要以局部变量的形式出现在类的内部。

**迪米特法则**

- 核心：降低类之间的耦合
- 注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系。

### 2.7 合成复用原则

- 基本介绍：尽量使用合成/聚合的方式，而不不是使用继承。(依赖、聚合、组合)

![image-20210915211256083](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210915211256083.png)

- 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。
- 针对接口编程，而不是针对实现编程。
- 为了交互对象间的松耦合设计而努力

## 3. UML

- UML(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助开发人员进行思考和记录思路的结果。
- UML本身是一套符号的规定，就像数学与化学符号，这些符号用来表示各个元素之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等。
- UML可以画时序图、用例图、类图。

### 3.1 UML类图

- 用于描述系统中的类(对象)本身的组成和类(对象)之间各种静态关系。
- 类之间的关系：依赖、泛化(继承)、实现、关联、聚合与组合。

### 3.2 类图—依赖关系

- 只要在**类中用到对方**，那么他们之间就存在依赖关系，如果没有对方，连编译都通过不了。

**类中用到对方的地方：**

- 类的成员属性
- 方法的返回类型
- 方法接收的参数类型
- 方法中使用到

**依赖使用虚线箭头，箭头指向依赖者**

<img src="https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916082804.png" style="zoom:80%;" />

### 3.3 类图—泛化关系

- 泛化关系实际上就是继承关系，他是依赖关系的特列。

- 泛化就是继承关系。

- 如果A继承了B，我们就说A和B存在泛化关系。

**泛化使用实线空心箭头，箭头指向继承类**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916083422.png)

### 3.4 类图—实现关系

- 实现关系就是A类(实现类)实现了B类(接口)，他就是依赖关系的特例。

**实现关系使用虚线空心箭头，接口指向接口**

<img src="https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916084003.png" style="zoom:80%;" />

### 3.5 类图—关联关系

- 关联关系实际上就是类与类之间的联系，他就是依赖关系的特例。
- 关联具有导航性：即双向关联或单项关联
- 关联具有多重性：一对多，一对一，多对一，多对多。

**关联使用实线箭头(单向关联)或者实线没有箭头(双向关联)，箭头指向被调用者**

<img src="https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916084503.png" style="zoom:80%;" />

可以通过上图看出，Person类中使用了IDCard类，但是IDCard类中没有使用到Person类，此时是单项一对一，并且存在箭头，这个箭头指向被调用的类。

而在第二个中，他们之间的类互相调用，所以此时是双向一对一关系，此时不存在箭头。

### 3.6 类图—聚合关系

- 聚合关系表示的是整体和部分的关系，**整体与部分可以分开**。聚合关系是关联关系的特例，所有它具有关联的导航性和多重性。

例如：一台计算机的键盘和显示器是可以从计算机中拆分出来的，使用带空心菱形的实线表示。（空心菱形从部分指向整体）

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916090413.png)

**聚合使用空心的菱形箭头，箭头指向调用者**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916090249.png)

### 3.7 类图—组合关系

- **组合也是整体与部分的关系，但是整体与部分不可以分开。(比如人与脑袋，就是组合关系)**

- 如果类中的成员变量不可以与整体类分离，就称为组合。比如上边的鼠标类如果不能与计算机分离，那么就是组合关系。(此时是new的对象，当Computer类加载时，鼠标类也会加载，当计算机类消失的时候，鼠标类也会随之消失，此时存在组合关系)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916090459.png)

- **组合使用的是实体的菱形箭头表示，箭头指向调用者。**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916090801.png)

区分组合与聚合：

- 人的头与人是你可以拆分的，所以此时就是组合关系。
- 人的身份证与人是可以拆分的，此时是聚合关系。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916091307.png)

 

