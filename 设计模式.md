# 23种设计模式

## 1.设计模式概念

### 1.1 什么地方可以用到设计模式

```markdown
面向对象(OO)=>功能模块[设计模式+算法(数据结构)]=>框架[使用多种设计模式]=>架构[服务器集群]
```

### 1.2 使用设计模式的好处

- 使用设计模式，软件具有很好的可扩展性(可以增加新的功能)
- 使用开发模式，具有很好的维护性(可读性、规范性)

### 1.3 设计模式的目的

- 设计模式是为了让程序，具有更好的代码重复性、可读性(编程规范性)、可扩展性(可维护性)、可靠性、是程序呈现**高内聚，低耦合**的特征。(模块内部逻辑关系非常紧密，模块与模块之间的关系非常的松散)
- 分享金句："懂了设计模式，你就懂了面向对象分析和面向对象设计(OOA/OOD)的精要"。

- C++老手与C++新手的区别就是，前者手背上有很多的伤疤。

## 2.设计模式的七大原则

- 设计模式原则，其实就是程序员在编译时，应当遵守的原则，也就是各种设计模式的基础(即：设计模式为什么这样设计的依据)

**设计模式常用的七大原则：**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210926224851.png)

- 单一职责原则

- 接口隔离原则
- 依赖倒转(倒置)原则
- 里氏替换原则
- 开闭原则
- 迪米特原则
- 合成复用原则(在一些地方不写这个原则)

### 2.1 单一职责原则

- 对于类来说，即一个类应该只负责一项职责。如果A类负责两个不同的职责：职责1、职责2。当职责1发生变化而改变A时，可能会对职责2造成影响使职责2运行错误，所以需要将类A的粒度分解为A1、A2。
- 如果再类中没有满足单一职责原则，在一个类的方法中遵守单一职责原则也是可以的(交通工具)

- 标准的单一职责原则，是在类的级别上进行拆分，而不是方法级别。

- 通常情况下，我们要遵守单一职责原则，只有当逻辑足够简单，才可以在代码级别违反单一职责原则；只有类中的方法数量足够少，可以在方法级别保持单一职责原则。

- 优秀的代码中使用类来区分多个分支，而不使用 if...else if()....else(耦合度高)

### 2.2 接口隔离原则

- 客户端不应该依赖它不需要接口，即一个类对另一个类的依赖应该建立在最小的接口上。
- 处理方式：将接口Interface拆分为独立的几个接口，类A与类C分别于他们需要的接口建立依赖关系。这就是使用的接口隔离原则。

没有使用接口隔离原则时的实现类图：(此时A、C要实现接口里的所有方法)

<img src="https://gitee.com/YunboCheng/imageBad/raw/master/image/20210911144651.png" style="zoom:80%;" />

使用接口隔离原则时的实现类图：(此时将接口进行了拆分，A此时只需要实现它要使用的方法对应的接口即可，而不用将接口中的方法全部实现)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210911144847.png)

### 2.3 依赖倒转(倒置)原则

- 在Java中，抽象是指接口或者抽象类，细节是指具体的实现类。

- 高层模块不应该依赖低层模块，二者都应该依赖其抽象(接口、抽象类)。
- 抽象类不应该依赖细节，细节应该依赖抽象类。

- 依赖倒倒转(倒置)的中心思想是面向接口编程。

**依赖倒转原则是基于这样的设计理念：**

- 相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比细节为基础的架构要稳定的多。
- 使用接口或者抽象类的目的是制定好规范，而不涉及任何具体的操作，把展示细节的任务交给他们的实现类去完成。

注意：在一个类文件中可以声明其他类、接口，只是这些都不能使用public修饰。但是声明的这些类和方法还是可以被其他的类继承或者实现的。

**依赖关系传递的三种方式**

- 接口传递
- 构造方法传递
- setter方式传递

**依赖原则要注意的地方**

- 底层模块尽量都要有抽象类和接口，或者两者都有，程序稳定性更好。
- 变量的声明类型尽量是抽象类和接口，这样我们的变量引用个实际对象间，就曾在一个缓冲层，利于程序的扩展和优化。(就比如你和对象吵架，你先找丈母娘来劝说对象，而不是与对象直接沟通)
- 继承时遵循里氏替换原则。

### 2.4  里氏替换原则

- 使用继承的时候，父类会对子类进行约束。并且如果父类中的方法发生改变的时候，可能会对所有的子类造成影响。

**里氏替换原则**

- 里氏替换原则是在1988年麻省理工学院的一个姓李的女士提出的。
- 所有引用基类的地方必须先是透明的使用其子类的对象。
- 在继承中，遵循里氏替换原则，在子类中尽量不在重写父类的方法。
- 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合、组合、依赖来解决问题。

**解决问题的办法**

- 原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等关系替代。

### 2.5 开闭原则(ocp原则)

- 开闭原则是编程中**最基础、最重要**的设计原则。
- 一个软件的实体如类、模块和函数应该对扩展开放(针对提供方)，对修改关闭(对使用者)。
- 用抽象构建架构，用实现扩展细节。
- 当软件需要变化时，尽量通**过扩展软件**实体的行为来实现变化，而**不是通过修改**已有的代码来实现。

- 编程中遵循其他原则，以及使用设计模式的的目的就是遵循开闭原则。

### 2.6 迪米特法则

- 一个对象应该对其他对象保持最少的了解。
- 类与类关系越密切，耦合度越大。
- **迪米特法则又叫最少知道原则**，即一个类对自己依赖的类知道的越少越好。也就是说，对于依赖的类不管多么的复杂，都尽量将逻辑封装在类的内部。对外除了了提供public 方法，不对外泄露任何信息。
- 迪米特法则还有个人更简单的定义：只与直接的朋友通信。
- **直接的朋友: **每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式有很多，依赖、关联、组合、聚合等。其中**，我们称出现在成员变量、方法参数、方法的返回值中的类为直接的朋友**，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类不要以局部变量的形式出现在类的内部。

**迪米特法则**

- 核心：降低类之间的耦合
- 注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系。

### 2.7 合成复用原则

- 基本介绍：尽量使用合成/聚合的方式，而不是使用继承。(依赖、聚合、组合)

![image-20210915211256083](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210915211256083.png)

- 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。
- 针对接口编程，而不是针对实现编程。
- 为了交互对象间的松耦合设计而努力

## 3. UML

- UML(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助开发人员进行思考和记录思路的结果。
- UML本身是一套符号的规定，就像数学与化学符号，这些符号用来表示各个元素之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等。
- UML可以画时序图、用例图、类图。

### 3.1 UML类图

- 用于描述系统中的类(对象)本身的组成和类(对象)之间各种静态关系。
- 类之间的关系：依赖、泛化(继承)、实现、关联、聚合与组合。

### 3.2 类图—依赖关系

- 只要在**类中用到对方**，那么他们之间就存在依赖关系，如果没有对方，连编译都通过不了。

**类中用到对方的地方：**

- 类的成员属性
- 方法的返回类型
- 方法接收的参数类型
- 方法中使用到

**依赖使用虚线箭头，箭头指向依赖者**

<img src="https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916082804.png" style="zoom:80%;" />

### 3.3 类图—泛化关系

- 泛化关系实际上就是继承关系，他是依赖关系的特列。

- 泛化就是继承关系。

- 如果A继承了B，我们就说A和B存在泛化关系。

**泛化使用实线空心箭头，箭头指向继承类**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916083422.png)

### 3.4 类图—实现关系

- 实现关系就是A类(实现类)实现了B类(接口)，他就是依赖关系的特例。

**实现关系使用虚线空心箭头，接口指向接口**

<img src="https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916084003.png" style="zoom:80%;" />

### 3.5 类图—关联关系

- 关联关系实际上就是类与类之间的联系，他就是依赖关系的特例。
- 关联具有导航性：即双向关联或单项关联
- 关联具有多重性：一对多，一对一，多对一，多对多。

**关联使用实线箭头(单向关联)或者实线没有箭头(双向关联)，箭头指向被调用者**

<img src="https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916084503.png" style="zoom:80%;" />

可以通过上图看出，Person类中使用了IDCard类，但是IDCard类中没有使用到Person类，此时是单项一对一，并且存在箭头，这个箭头指向被调用的类。

而在第二个中，他们之间的类互相调用，所以此时是双向一对一关系，此时不存在箭头。

### 3.6 类图—聚合关系

- 聚合关系表示的是整体和部分的关系，**整体与部分可以分开**。聚合关系是关联关系的特例，所有它具有关联的导航性和多重性。

例如：一台计算机的键盘和显示器是可以从计算机中拆分出来的，使用带空心菱形的实线表示。（空心菱形从部分指向整体）

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916090413.png)

**聚合使用空心的菱形箭头，箭头指向调用者**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916090249.png)

### 3.7 类图—组合关系

- **组合也是整体与部分的关系，但是整体与部分不可以分开。(比如人与脑袋，就是组合关系)**

- 如果类中的成员变量不可以与整体类分离，就称为组合。比如上边的鼠标类如果不能与计算机分离，那么就是组合关系。(此时是new的对象，当Computer类加载时，鼠标类也会加载，当计算机类消失的时候，鼠标类也会随之消失，此时存在组合关系)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916090459.png)

- **组合使用的是实体的菱形箭头表示，箭头指向调用者。**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916090801.png)

区分组合与聚合：

- 人的头与人是你可以拆分的，所以此时就是组合关系。
- 人的身份证与人是可以拆分的，此时是聚合关系。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210916091307.png)

##  4.设计模式

### 4.1 设计模式概念和分类

- 概念：设计模式的本质提高软件的维护性、通用性和扩展性，并降低软件的复杂度。
- 《设计模式》是经典的书，作者俗称“四人组 GOF”。
- 设计模式并不是局限于某种语言的，Java、C++、PHP都有设计模式。

### 4.2  设计模式的分类

- 创建型模式：单列模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
- 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
- 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式(Interperter模式)、状态模式、策略模式、职责链模式(责任链模式)。

**注意：不同书籍对哦分类和名称略有差别。**

## 5. 单例模式

- 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对**某个类只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法(静态方法)。

![image-20210923194636842](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210923194636842.png)

![image-20210923200228383](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210923200228383.png)

- 以上是使用单例模式实现的步骤。

### 5.1 单例（静态常量饿汉式）推荐使用

- 之所以叫饿汉式，不论用不用这个类的对象，只要加载类的时候就会创建出来这个类的一个对象。
- 饿汉式是线程安全的。

- 使用饿汉式对象在类加载的时候就会被创建。

- 使用类名.静态方法 获取到类的唯一对象。

![image-20210923200325088](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210923200325088.png)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210923200340.png)

- 这种单例模式可能会造成内存的浪费，因为这个对象在类加载的时候就创建出来了，如果在主方法中没有用到这个对象，就相当于白创建了这个对象，此时会造成内存的浪费。

### 5.2 单列（静态代码块饿汉式）推荐使用

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210923201132.png)

- 这种写法和上边的一样，可能会造成内存浪费。

### 5.3 单例（线程不安全懒汉式）

- 之所以叫懒加载是因为只有用到的时候才会加载，不用到的时候不会去加载这个对象。

- 使用懒汉式可以解决内存浪费问题，只有调用getInstance() 方法的时候才会创建对象，并且在第二次调用方法的时候，不会在从新创建一个新的对象，而是返回第一次创建的对象，保证单例模式。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210923201704.png)

- 以上编写的代码，虽然起到了懒汉式的作用，但是**只能在单线程之下使用**。
- 如果在多线程下，一个线程刚刚进入到 if(instance == null) 判断语句块，还没来得及往下执行，也就是还没有创建出一个对象，另一个线程也通过了这个判断语句，这会便会产生多个实例对象。所以在多线程下是不安全的。
- 在实际开发中，不要使用这种方式。 

### 5.4 单例（懒汉式：线程安全，同步方法）

- 将创建对象的方法使用 synchronized关键字来修饰，这样就可以保证线程安全，此时多个线程调用getInstance()方法的时候需要排队，等待上一线程结束才可以进行下一个线程的调用，因为此时上一个线程已创建出一个对象，此时就不会在创建出一个新的对象。不仅保证了线程安全，还可以实现单例模式。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210923203948.png)

- 以上这种方式实现的效率太低，因为每次调用方法的时候都需要排队。

### 5.5 单例（懒汉式：线程安全，同步代码块）

- 此时将 synchronized 写到 if() 条件判断中，只要多个线程都进入if()判断中，一定是线程不安全的，在实际开发种不可以使用这种方式。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210923204818.png)

![image-20210923205201920](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210923205201920.png)

### 5.6 双重检查（线程安全，效率高，懒汉式模式）推荐使用

- 在实际开发中，推荐使用这种方式。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210923212446.png)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210923213017.png)

### 5.7 单例（静态内部类）推荐使用

- 推荐使用。

- JVM在装载类的时候是线程安全的。

- 可以保证线程安全、实现了懒加载、保证了效率。
- 这里保证只创建一个实例对象，使用的机制是静态内部类只会加载一次，所以只执行一次对象的创建。
- 这里保证懒加载是因为在加载 Singleton 类的时候不会创建对象，只有调用 getInstance() 方法的时候会使用静态内部类来创建对象。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210923214344.png)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210923215306.png)

### 5.8 单例（枚举）推荐使用

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210923215910.png)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210923215942.png)

- 在JDK的RunTime的源码中使用到了单例模式。
- 单例模式的特点之一：不是new出来的，而是使用方法调用出来的。



## 6.工厂模式

### 6.1 简单工厂模式（静态工厂模式）

- 简单工厂模式属于创建型模式，是工厂模式的一种。**简单工厂模式是由一个工厂对象决定创建出哪一种产品类型的实例。**简单工厂模式是工厂模式家族中最简单实用的模式。
- 简单工厂模式：定义一个创建对象的类，由这个类来 **来封装实例化对象的行为(代码)**
- 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。



实现一个需求：客户可以点任意口味的披萨，奶酪披萨、胡椒等等。

**实现原理：**

- 我们创建一个 SimpleFactory 工厂类，这个类负责创建出实例对象，用户给这个工厂传递需求(比如需要创建的对象)，这个工厂类会通过自己类中封装的代码(行为)来创建出对应的实例对象

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927101715.png)

- 以下就是这个简单工厂类，将这个工厂使用聚合或者组合的方式为每一个小店铺添加。这样的话不需要改变小店铺中的代码，只需要改变工厂类中的行为即可。

![image-20210927102547268](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210927102547268.png)

- 简单工厂模式要比静态工厂模式灵活，简单工厂模式可以任意的改变不同对象的不同行为，而静态工厂模式中行为是一样的，每个对象使用的都是这几个行为。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927103301.png)

### 6.2 工厂方法模式

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927104357.png)

- **工厂方法模式设计方案：**将披萨项目的实例化功能抽象成方法，在不同的口味点餐子类中具体实现。
- **工厂方法模式**：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将**对象的实例化推迟到子类。**



**实现原理**：

1. 将OrderPizza类声明为抽象类。BJOrderPizza和LDOrderPizza定义为实现这个抽象类的子类，在这个子类中文成披萨的创建。

![image-20210927111646437](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210927111646437.png)

2. 定义不同地区不同类型的披萨。（定义四个类，按照以下格式依此类推）

   ![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927112842.png)

3. 以下就是创建的这个抽象的父类，这个类来声明创建披萨对象的方法，使用其子类具体实现这个工厂类。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927112030.png)

- 让子类继承这个抽象工厂类，在这个子类中创建出关于北京不同的披萨类型。

![image-20210927112747938](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210927112747938.png)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927113249.png)

- 实现顾客选定披萨

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927114157.png)

### 6.3 抽象工厂模式

- 抽象工厂模式：定义了一个interface用于创建相关或者有依赖关系的对象簇，而无需指明具体的类。
- 抽象工厂类可以将 **简单工厂模式**和 **工厂方法模式**进行整合。
- 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)
- 将工厂抽象为两层，AbsFactory（抽象工厂）和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样讲单个的加单工厂类变成了工厂簇。更利于代码的维护和扩展。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927145747.png)

- 以上的四个披萨类和上边的简单工厂是一样的。
- 以下是抽象工厂类。

![image-20210927150611135](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210927150611135.png)

- 以下是两个工厂子类，分别实现不同地区的披萨。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927150747.png)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927150956.png)

- 以下是一个实现选择披萨的类。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927152547.png)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927152631.png)

- 以下是最终实现用户选择披萨的类。

![image-20210927152755380](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210927152755380.png)

**工厂模式小结:**

- 工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系解耦。从而提高项目的扩展性和维护性。
- 三种工厂模式（简单工厂模式、工厂方法模式、抽象工厂模式）

**工厂模式使用了设计模式的依赖抽象原则：**

- 创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。
- 不要让类继承具体类，而是继承抽象类或者是实现interface(接口)。
- 不要覆盖基类中已实现的方法。

## 7. 原型模式

### 7.1 原型模式（克隆羊）

![image-20210927165837695](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210927165837695.png)

- 原型模式是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。
- 原型模式是一种创建型设计模式，允许一个对象在创建另一个可定制的对象，无需知道如何创建的细节。
- 工作原理是：通过将一个原型对象传递给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝他们自己来实施创建，即 **对象.clone()** 

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927170902.png)

### 7.2 原型模式（浅拷贝）

- 深拷贝解决的问题是在克隆对象的时候应该如何处理。

- **使用浅拷贝方法拷贝的对象，并不会新克隆出一个对象，克隆出来的对象和原始对象指向同一个地址，也就是说克隆出来的对象和被克隆的对象是同一个对象。**
- 上边的克隆羊就是属于浅拷贝。(不会创建出新的对象)

![image-20210927204350497](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210927204350497.png)

### 7.3 原型模式（深拷贝）

- 深拷贝的核心就是 克隆出来的对象是一个全新的对象，有自己的内存空间。

![image-20210927205126355](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210927205126355.png)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927210538.png)

## 8.建造者模式

**建造者模式介绍**

- **建造者模式**又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
- **建造者模式** 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型个内容就就可以构建他们，用户不需要知道内部的具体构建细节。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927223032.png)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210928085312.png)

**盖房项目需求**

- 需要建房子：这一过程为打桩、砌墙、封顶。
- 房子有各种各样的类型：普通房、别墅、高楼大厦，各种房子的建造过程虽然一样，但是要求不一样。

**使用普通模式实现盖房子需求**

我们可以采取继承的方式来构建不同的房子。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210927214446.png)

- 优点：比较好理解，简单易于操作。

- 缺点：这种程序结构，设计简单，没有设计缓存层对象，程序的扩展和维护不好，也就是说，这种设计方案，把产品（即：房子）和创建产品的过程（即：建房子流程）封装在一起，耦合度增强了。
- 解决方案：将产品与产品建造的过程解耦==》建造者模式。


**使用构造者模式实现盖房子的需求**

- 以下是盖房子时是用建造者模式的类图

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210928091628.png)

**建造者模式**

- 客户端(使用程序)不必知道产品内部组件的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
- 每一个具体的建造者都相对独立，而与其他的具体建造者无关，因此可以很方方便地替换具体建造者或增加具体建造者，**用户使用不同的具体建造者即可得到不同的产品对象**
- **可以更加精细的控制产品的创建过程。**将复杂产品的创建步骤分解在不同方法中，使得创建过程更加清晰，也更加方便使用程序来控制床架过程。
- **增加新的具体的建造者无须修改原有类库的代码**，指挥者类针对抽象建造者编程，系统扩展方便，符合 **开闭原则**

- 建造者模式所创建的产品一般具有较多的共性，其组成部分相似(比如盖房子)，**如果产品之间的差异性很大，则不适合使用建造者模式**，因此其使用范围有一定的限制 。
- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，需考虑是否选择建造者模式。

**抽象工厂模式VS建造者模式**

- 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品；具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。

## 9. 适配器模式

### 9.1 适配器介绍

- 适配器模式(包装器)：将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口因接口不匹配不能在一起工作的两个类可以协同工作。
- 适配器模式属于结构性模式。
- 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式。

### 9.2 工作原理

- 适配器模式：将一个类的接口转换成另一种接口，让 **原本接口不兼容的类可以兼容。**
- 从用户的角度看不到被适配者。
- 用户调用适配器转换出来的目标接口方法，适配器再调用被适配者的相关接口方法。
- 用户收到反馈结果，感觉只是和目标接口交互，如图：

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210928110025.png)

### 9.3 类适配器

**类适配器模式介绍**

基本介绍：Adapter类，通过继承src类，实现dst类接口，完成src-->dst的适配。

**类适配器模式应用案列**

以生活中充电器的例子来讲解，充电器本身相当于Adapter，220v交流电相当于src(即被适配者)。我们的目的是dst(即：目标)是5v直流电。

![image-20210928111026323](C:/Users/YunboCheng/AppData/Roaming/Typora/typora-user-images/image-20210928111026323.png)

 

这里VoltagAdapter是适配器类，这个类继承了220v的这个被适配的类，实现了5v的这个接口，Phone是手机类，这个类依赖5v的这个接口其实就是依赖的VoltageAdapter这个适配器类。Clinet是用户类，这个用户依赖手机类和这个适配器类。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210928112737.png)

- **以上代码实现方式见 adapter类 包**

使用**类适配器**的缺点

- Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定的局限性。
- src类的方法在Adapter中都会暴露出来，也增加了使用的成本。

使用**类适配器**的优点

- 由于其继承了src类，所以它可以根据需求重写src类的方法，是得Adapter的灵活性增强了。

### 9.4 对象适配器

**对象适配器模式介绍**

- 基本介绍：和类适配器模式差不错，只是将Adapter类作为修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现dst类接口，完成src-->dst的适配。
- 根据”合成复用原则”，在系统中尽量使用关联关系来代替继承关系。
- **对象适配器模式是适配器模式中常用的一种**

![image-20210928174226595](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210928174226595.png)

- 对象适配器和类适配器其实算是一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。
- 使用成本更低，更灵活。

### 9.5 接口适配器模式

**接口适配器模式介绍**

- 一些书籍称为：适配者模式或者缺省适配器模式。
- 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中的每个方法提供一个默认实现（空方法），那么该抽象类的子类可以有选择的覆盖重写父类的某些方法来实现需求。
- **适用于一个接口不想使用其所有方法的情况。**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210928215833.png)

 ![image-20210928215344532](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210928215344532.png)

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210928220234.png)

- 一下代码是使用的匿名内部类来实现的。因为AbsAdapter 是一个抽象类，不可以直接new出来，需要实现具体的方法。

![image-20210928220613511](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210928220613511.png)

**对适配器的总结**

- 适配器的三种命名方式，是根据src（被适配者）是以怎样的形式给到Adapter(在Adapter里的形式，Adapter是适配器类)类命名的。

  类适配器：以类给到，在Adapter里，就是将src当作类。（继承）。

  对象适配器：以对象给到，在Adapter里，将src作为一个对象。(聚合、组合)。

  接口适配器：以接口给到，在Adapter里，将src作为一个接口。(实现)

- Adapter模式最大的作用还是将原本不兼容的接口结合在一起工作。

- 实际开发中，实现起来并不拘泥这三种经典的形式。

## 10.桥接模式

### 10.1 使用普通模式实现问题

**问题引入（手机操作问题）**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210929091238.png)

**使用传统的方式解决这个问题的类图**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210929091354.png)

**使用传统方式解决问题的缺点**

- 扩展性问题(类爆炸)，如果我们在增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也需要在各个手机样式类下增加。
- 违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本。

### 10.2 桥接模式介绍

- 桥接模式是指：将实现与抽象放在两个不同的类层次中，是两个层次可以独立改变。
- 桥接模式是一种结构型设计模式。
- 桥接模式基于 **类的最小设计原则**,通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象与行为实现分离开来，从而可以保持各个部分的独立性以及应对他们的功能扩展。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210929093210.png)

- 以上 Implementor 是一个接口，Abstraction是一个抽象类，剩下的类都是具体的实现类。

### 10.3 使用桥接模式实现问题

**桥接模式实习的类图**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210929093644.png)

- 项目源代码加 bridging 包

**桥接模式的总结**

- 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分分别独立出来，这有助于系统进行分层设计，从而产生更好的结构化系统。
- 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。
- 桥接模式由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。
- 桥接模式要求正确的识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。

**桥接模式的使用场景**

![image-20210929112858850](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210929112858850.png)

## 11. 装饰者模式

### 11.1 使用普通模式实现问题

**问题引入（咖啡馆）**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210929113452.png)

**使用传统方式解决问题类图**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210929114538.png)

- 问题在于这种写法会产生类爆炸。

![image-20210929145139813](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210929145139813.png)

### 11.2 装饰者模式介绍

- 装饰者模式：**动态的将新的功能附加到对象上**。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(OCP)

**装饰者模式的原理**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210929150856.png)

### 11.3 使用装饰者模式解决星巴克问题

**使用装饰者模式解决上述咖啡问题的方案图**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210929151444.png)

**装饰者模式下的订单：2分巧克力+1份牛奶的LongBlack(单品咖啡)**，我们生活着的思想是将配料加到咖啡中，但是使用装饰者模式的思想是：将单品咖啡加入到配料中。

![image-20210929151909305](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210929151909305.png)

## 12. 组合模式

### 12.1 使用普通模式是实现问题

**问题引入（学校院系展示需求）**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210929152522.png)

**使用传统解决问题的类图**使用组合的方式，学校中包含学院，学院中包含系。

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210929152638.png)

**使用传统方案的问题分析**

- 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的。
- 实际上我们的要求是：在一个页面中展示出一个学校的院系组成，一个学校有多少个学院，一个学院有多少个系，因此这种解决方案不能很好实现管理的操作。比如对学院、系得添加、删除和遍历等。
- 解决方案：把学校、学院、系都看做是组织结构，他们之间没有继承得关系，而是一个树形结构，可以更好得实现管理操作 ==> 组合模式。

### 12.2 组合模式简介

- 组合模式，又叫**部分整体模式**，它创建了对象组的树形结构，将对象组合成树状结构以表示”整体—部分”的层次关系。
- 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
- 这种类型的设计模式属于结构型设计模式。
- 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象。

**组合模式原理类图**

![](https://gitee.com/YunboCheng/imageBad/raw/master/image/20210929155132.png)

![image-20210929155318828](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210929155318828.png)

### 12.3  使用组合模式解决问题

**使用组模式解决文艺的类图**这里的 OrganizationComponent 可以是接口、抽象类、普通类。

![image-20210929164542987](https://gitee.com/YunboCheng/imageBad/raw/master/image/image-20210929164542987.png)

- 简化客户端操作。
- 具有较强的扩展性。
- 方便创建出复杂的层次结构。
- 需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合组合模式。
- 需要较高的抽象性。如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样。不适合使用组合模式。吧

## 13.外观模式

### 13.1 使用普通模式实现问题

**问题引入（影院项目管理）**

